# README: Exam M2 - Algorithm Analysis

## üìã Overview
‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡∏ô‡∏µ‡πâ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏™‡∏≠‡∏ö‡∏Å‡∏•‡∏≤‡∏á‡∏†‡∏≤‡∏Ñ M2 ‡∏ó‡∏±‡πâ‡∏á 2 ‡∏Ç‡πâ‡∏≠ ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏≠‡∏±‡∏•‡∏Å‡∏≠‡∏£‡∏¥‡∏ó‡∏∂‡∏° ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå

---

## üéØ ‡∏Ç‡πâ‡∏≠ 1: Histogram Select (k-th Order Statistic)

### üìñ ‡πÇ‡∏à‡∏ó‡∏¢‡πå
‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á **k-th** ‡πÉ‡∏ô‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏£‡∏¢‡πå‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç (double) ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ **Histogram-based Selection Algorithm**

### üîë Input/Output
```
Input:
n b                    // n = ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•, b = ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô bins
a‚ÇÅ a‚ÇÇ ... a‚Çô          // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• n ‡∏ï‡∏±‡∏ß
k                      // ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤ (1-indexed)

Output:
‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà k
```

### üí° Algorithm: Divide and Conquer

**‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î:**
1. ‡πÅ‡∏ö‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô **b bins** ‡∏ï‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏á‡∏Ñ‡πà‡∏≤
2. ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ bin
3. ‡∏´‡∏≤ bin ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á k (‡∏î‡∏π‡∏à‡∏≤‡∏Å cumulative count)
4. **Recursive:** ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô bin ‡∏ô‡∏±‡πâ‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏≥‡∏ã‡πâ‡∏≥‡∏à‡∏ô‡πÄ‡∏à‡∏≠‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö

**‡πÇ‡∏Ñ‡πâ‡∏î‡∏´‡∏•‡∏±‡∏Å:**
```java
double histogramSelect(ArrayList<Double> A, int b, int k) {
    if (A.size() == 1) return A.get(0);
    
    double min = findMin(A);
    double max = findMax(A);
    double width = (max - min) / b;  // ‚ùó‡∏´‡∏≤‡∏£ width ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà b
    
    int[] count = new int[b];
    for (double value : A) {
        int idx = (int) ((value - min) / width);
        if (idx >= b) idx = b - 1;
        count[idx]++;
    }
    
    int additive = 0, targetBin = -1;
    for (int i = 0; i < b; i++) {
        if (additive + count[i] >= k) {
            targetBin = i;
            break;
        }
        additive += count[i];
    }
    
    ArrayList<Double> selected = new ArrayList<>();
    double rangeStart = min + targetBin * width;
    double rangeEnd = rangeStart + width;
    
    for (double value : A) {
        if ((value >= rangeStart && value < rangeEnd) || 
            (value == max && targetBin == b - 1)) {
            selected.add(value);
        }
    }
    
    k = k - additive;
    return histogramSelect(selected, b, k);
}
```

### üîç ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (in1.txt)

**Input:**
```
20 4
145. 56. 49. 89. 137. 90. 62. 33. 71. 77.
92. 145. 153. 108. 74. 146. 183. 120. 80. 93.
7
```

**Output:** `77.0`

**‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:**
```
‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö: [33, 49, 56, 62, 71, 74, 77, 80, 89, 90, 92, 93, 108, 120, 137, 145, 145, 146, 153, 183]
‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà 7 = 77.0 ‚úì
```

### ‚öôÔ∏è Complexity
- **Average:** O(n log_b n)
- **Worst:** O(n¬≤)
- **Space:** O(n)

### ‚ö†Ô∏è ‡∏à‡∏∏‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ß‡∏±‡∏á

**1. ‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢ width ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà b**
```java
int idx = (int) ((value - min) / width);  // ‚úÖ ‡∏ñ‡∏π‡∏Å
```

**2. ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ max value**
```java
if (idx >= b) idx = b - 1;
```

**3. ‡∏´‡∏≤ min/max ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á**
```java
double min = A.get(0);  // ‚úÖ
// ‚ùå ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏ä‡πâ Double.MIN_VALUE (‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡πà‡∏≤‡∏ö‡∏ß‡∏Å‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î)
```

---

## üèîÔ∏è ‡∏Ç‡πâ‡∏≠ 2: Sand (Optimal Merging Problem)

### üìñ ‡πÇ‡∏à‡∏ó‡∏¢‡πå
‡∏°‡∏µ‡∏Å‡∏≠‡∏á‡∏ó‡∏£‡∏≤‡∏¢ `n` ‡∏Å‡∏≠‡∏á ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏≠‡∏á‡∏°‡∏µ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å `w[i]`  
‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏Å‡∏≠‡∏á 2 ‡∏Å‡∏≠‡∏á ‡∏à‡∏∞‡πÄ‡∏™‡∏µ‡∏¢‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢ = **‡∏ú‡∏•‡∏£‡∏ß‡∏°‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á 2 ‡∏Å‡∏≠‡∏á**

‡∏´‡∏≤**‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏£‡∏ß‡∏°‡∏ï‡πà‡∏≥‡∏™‡∏∏‡∏î**‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏Å‡∏≠‡∏á‡∏ó‡∏£‡∏≤‡∏¢‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 1 ‡∏Å‡∏≠‡∏á

### üîë Input/Output
```
Input:
n                      // ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≠‡∏á‡∏ó‡∏£‡∏≤‡∏¢
w‚ÇÅ w‚ÇÇ ... w‚Çô          // ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏≠‡∏á (long)

Output:
‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏£‡∏ß‡∏°‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
```

### ‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÉ‡∏ô‡∏™‡∏≠‡∏ö
**‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞:** `ArrayList`, `List`, `Scanner`  
**‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏ä‡πâ:** `PriorityQueue`, `Collections.sort()`, `Arrays.sort()`

### üí° Algorithm: Greedy + Min-Heap

**‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î:**
- **Greedy Strategy:** ‡∏£‡∏ß‡∏°‡∏Å‡∏≠‡∏á‡πÄ‡∏•‡πá‡∏Å 2 ‡∏Å‡∏≠‡∏á‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏™‡∏°‡∏≠
- **Why?** ‡∏Å‡∏≠‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏Ñ‡∏ß‡∏£‡πÉ‡∏´‡πâ‡∏Ñ‡πà‡∏≤‡∏°‡∏±‡∏ô‡∏ô‡πâ‡∏≠‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
- **Data Structure:** ‡∏™‡∏£‡πâ‡∏≤‡∏á Min-Heap ‡πÄ‡∏≠‡∏á‡∏î‡πâ‡∏ß‡∏¢ ArrayList (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ PriorityQueue)
- **‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢:** Huffman Coding Algorithm

**‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Min-Heap:**
```
         8
       /   \
      16    16
     / \   / \
    32 32 48 48

Parent: (i-1)/2
Left:   2*i+1
Right:  2*i+2
```

**‡πÇ‡∏Ñ‡πâ‡∏î‡∏´‡∏•‡∏±‡∏Å:**
```java
// 1. Build min-heap from input (O(n))
heap = new ArrayList<>(A);
for (int i = n/2-1; i >= 0; i--) {
    heapifyDown(i);
}

// 2. Repeatedly merge two smallest (O(n log n))
long totalCost = 0L;
while (heap.size() > 1) {
    long a = extractMin();    // ‡∏î‡∏∂‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î O(log n)
    long b = extractMin();    // ‡∏î‡∏∂‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏£‡∏≠‡∏á O(log n)
    long sum = a + b;
    totalCost += sum;         // ‡∏ö‡∏ß‡∏Å‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢
    insert(sum);              // ‡πÉ‡∏™‡πà‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤ heap O(log n)
}
return totalCost;
```

**Heap Operations:**
- `extractMin()`: ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î (root) ‡πÅ‡∏•‡πâ‡∏ß heapifyDown - O(log n)
- `insert(value)`: ‡πÉ‡∏™‡πà‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏ó‡πâ‡∏≤‡∏¢ heap ‡πÅ‡∏•‡πâ‡∏ß heapifyUp - O(log n)
- `heapifyDown(i)`: ‡∏¢‡πâ‡∏≤‡∏¢ node ‡∏•‡∏á‡∏´‡∏≤ position ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å - O(log n)
- `heapifyUp(i)`: ‡∏¢‡πâ‡∏≤‡∏¢ node ‡∏Ç‡∏∂‡πâ‡∏ô‡∏´‡∏≤ position ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å - O(log n)

---

### üìù ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÇ‡∏Ñ‡πâ‡∏î‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏™‡πà‡∏ß‡∏ô

#### **1. Heap Operations (‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏≠‡∏á - ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ PriorityQueue)**

**swap() - ‡∏™‡∏•‡∏±‡∏ö‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á:**
```java
private void swap(int i, int j) {
    long temp = heap.get(i);
    heap.set(i, heap.get(j));
    heap.set(j, temp);
}
```

**heapifyUp() - ‡∏¢‡πâ‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏ô (‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏±‡∏á insert):**
```java
private void heapifyUp(int i) {
    while (i > 0) {
        int parent = (i - 1) / 2;           // ‡∏´‡∏≤ parent
        if (heap.get(i) < heap.get(parent)) { // ‡∏ñ‡πâ‡∏≤‡∏•‡∏π‡∏Å‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏°‡πà
            swap(i, parent);                 // ‡∏™‡∏•‡∏±‡∏ö
            i = parent;                      // ‡∏¢‡πâ‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏õ
        } else break;                        // ‡∏ñ‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏¢‡∏∏‡∏î
    }
}
```
- **‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠:** insert ‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà‡∏ó‡πâ‡∏≤‡∏¢ heap
- **‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:** ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö parent ‡∏ñ‡πâ‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤‡∏Å‡πá‡∏™‡∏•‡∏±‡∏ö‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏õ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏¢ ‡πÜ
- **Time:** O(log n) - ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÑ‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á tree

**heapifyDown() - ‡∏¢‡πâ‡∏≤‡∏¢‡∏•‡∏á‡∏•‡πà‡∏≤‡∏á (‡πÉ‡∏ä‡πâ‡∏´‡∏•‡∏±‡∏á extract ‡πÅ‡∏•‡∏∞ build heap):**
```java
private void heapifyDown(int i) {
    int n = heap.size();
    while (true) {
        int smallest = i;
        int left = 2 * i + 1;   // left child
        int right = 2 * i + 2;  // right child

        // ‡∏´‡∏≤ child ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πá‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
        if (left < n && heap.get(left) < heap.get(smallest))
            smallest = left;
        if (right < n && heap.get(right) < heap.get(smallest))
            smallest = right;

        if (smallest != i) {    // ‡∏ñ‡πâ‡∏≤ child ‡πÄ‡∏•‡πá‡∏Å‡∏Å‡∏ß‡πà‡∏≤ parent
            swap(i, smallest);  // ‡∏™‡∏•‡∏±‡∏ö
            i = smallest;       // ‡∏¢‡πâ‡∏≤‡∏¢‡∏•‡∏á‡πÑ‡∏õ
        } else break;           // ‡∏ñ‡∏π‡∏Å‡∏ó‡∏µ‡πà‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏¢‡∏∏‡∏î
    }
}
```
- **‡πÉ‡∏ä‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠:** extract root ‡∏´‡∏£‡∏∑‡∏≠ build heap
- **‡∏ó‡∏≥‡∏á‡∏≤‡∏ô:** ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö children ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏•‡∏±‡∏ö‡∏•‡∏á‡πÑ‡∏õ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏¢ ‡πÜ
- **Time:** O(log n) - ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏•‡∏á‡πÑ‡∏õ‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏Ç‡∏≠‡∏á tree

**insert() - ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡∏°‡πà:**
```java
private void insert(long value) {
    heap.add(value);              // ‡πÉ‡∏™‡πà‡∏ó‡πâ‡∏≤‡∏¢ heap
    heapifyUp(heap.size() - 1);   // ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏∂‡πâ‡∏ô‡∏ö‡∏ô‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ó‡∏µ‡πà
}
```
- **‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô:** ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î ‚Üí heapifyUp
- **Time:** O(log n)

**extractMin() - ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î:**
```java
private long extractMin() {
    long min = heap.get(0);           // ‡∏î‡∏∂‡∏á root (‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î)
    int last = heap.size() - 1;
    heap.set(0, heap.get(last));      // ‡πÄ‡∏≠‡∏≤‡∏ï‡∏±‡∏ß‡∏ó‡πâ‡∏≤‡∏¢‡∏°‡∏≤‡πÅ‡∏ó‡∏ô root
    heap.remove(last);                // ‡∏•‡∏ö‡∏ï‡∏±‡∏ß‡∏ó‡πâ‡∏≤‡∏¢
    if (!heap.isEmpty())
        heapifyDown(0);               // ‡∏õ‡∏£‡∏±‡∏ö‡∏•‡∏á‡∏•‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ó‡∏µ‡πà
    return min;
}
```
- **‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô:** ‡πÄ‡∏Å‡πá‡∏ö root ‚Üí ‡∏¢‡πâ‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏ó‡πâ‡∏≤‡∏¢‡∏°‡∏≤ root ‚Üí ‡∏•‡∏ö‡∏ï‡∏±‡∏ß‡∏ó‡πâ‡∏≤‡∏¢ ‚Üí heapifyDown
- **Time:** O(log n)

#### **2. Main Algorithm (sandSort)**

**Build Heap - O(n):**
```java
heap = new ArrayList<>(A);
// Bottom-up heapify (‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ insert ‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß!)
for (int i = n/2-1; i >= 0; i--) {
    heapifyDown(i);
}
```
- **‡∏ó‡∏≥‡πÑ‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà n/2-1?** ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ node ‡∏´‡∏•‡∏±‡∏á n/2 ‡πÄ‡∏õ‡πá‡∏ô leaf (‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏•‡∏π‡∏Å) ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á heapify
- **‡∏ó‡∏≥‡πÑ‡∏°‡∏ñ‡∏∂‡∏á O(n)?** ‡πÅ‡∏°‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏õ‡πá‡∏ô O(log n) ‡πÅ‡∏ï‡πà‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ O(n) (mathematical proof)

**Merge Loop - O(n log n):**
```java
long totalCost = 0L;
while (heap.size() > 1) {
    long a = extractMin();  // ‡∏î‡∏∂‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏™‡∏∏‡∏î - O(log n)
    long b = extractMin();  // ‡∏î‡∏∂‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏£‡∏≠‡∏á - O(log n)
    long sum = a + b;       // ‡∏£‡∏ß‡∏°‡∏Å‡∏±‡∏ô
    totalCost += sum;       // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢
    insert(sum);            // ‡πÉ‡∏™‡πà‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏Ç‡πâ‡∏≤ heap - O(log n)
}
return totalCost;
```
- **‡∏ó‡∏≥‡∏ã‡πâ‡∏≥:** n-1 ‡∏£‡∏≠‡∏ö (‡∏£‡∏ß‡∏°‡∏à‡∏ô‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)
- **‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≠‡∏ö:** 3 √ó O(log n) = O(log n)
- **‡∏£‡∏ß‡∏°:** (n-1) √ó O(log n) = **O(n log n)** ‚úì

---

### üîç ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á (in1.txt)

**Input:**
```
10
8 8 8 8 8 8 8 8 8 8
```

**Output:** `272`

**‡∏™‡∏£‡∏∏‡∏õ:** ‡∏£‡∏ß‡∏° 10 ‡∏Å‡∏≠‡∏á‡∏Ç‡∏ô‡∏≤‡∏î 8 ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏£‡∏ß‡∏° = **272** ‡πÉ‡∏ô **9 ‡∏£‡∏≠‡∏ö** ‚úì

### ‚öôÔ∏è Complexity

- **Time:** O(n log n) ‚Äî Build heap: O(n), Extract+Insert: O(n log n)
- **Space:** O(n)
- **‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö:** PriorityQueue ‡πÅ‡∏ï‡πà‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÄ‡∏≠‡∏á! ‚úÖ

### ‚ö†Ô∏è ‡∏à‡∏∏‡∏î‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ß‡∏±‡∏á

**1. Build heap ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**
```java
for (int i = n/2-1; i >= 0; i--) {
    heapifyDown(i);  // O(n) - ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤‡πÉ‡∏™‡πà‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß
}
```

**2. HeapifyDown ‡∏´‡∏•‡∏±‡∏á extract**
```java
heap.set(0, heap.get(last));
heap.remove(last);
if (!heap.isEmpty()) heapifyDown(0);  // ‚ùó‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç!
```

**3. HeapifyUp ‡∏´‡∏•‡∏±‡∏á insert**
```java
heap.add(value);
heapifyUp(heap.size() - 1);  // ‚ùó‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç!
```

**4. ‡πÉ‡∏ä‡πâ long ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà int**
```java
long totalCost = 0L;
ArrayList<Long> heap = ...;
```

---

## üìÇ Test Cases & Results

### ‡∏Ç‡πâ‡∏≠ 1: Histogram Select (in1.txt - in10.txt)

| Test | Output | Status |
|------|--------|--------|
| in1.txt | `77.0` | ‚úÖ |
| in2.txt | `99.43` | ‚úÖ |
| in3.txt | `18.0` | ‚úÖ |
| in4.txt | `1286.3` | ‚úÖ |
| in5.txt | `68.16` | ‚úÖ |
| in6.txt | `111.0` | ‚úÖ |
| in7.txt | `132.0` | ‚úÖ |
| in8.txt | `443.4` | ‚úÖ |
| in9.txt | `602.8` | ‚úÖ |
| in10.txt | `75.72` | ‚úÖ |

**‡∏™‡∏£‡∏∏‡∏õ:** ‚úÖ 10/10 ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (100%)

---

### ‡∏Ç‡πâ‡∏≠ 2: Sand - Regular Cases (in1.txt - in10.txt)

| Test | n (piles) | Output | Status |
|------|-----------|--------|--------|
| in1.txt | 10 | `272` | ‚úÖ |
| in2.txt | 45 | `186071874` | ‚úÖ |
| in3.txt | 10,000 | `65459537179` | ‚úÖ |
| in4.txt | 20 | `1408` | ‚úÖ |
| in5.txt | 100 | `11971` | ‚úÖ |
| in6.txt | 1,000 | `297148` | ‚úÖ |
| in7.txt | 50,000 | `1463500352` | ‚úÖ |
| in8.txt | 50 | `3060` | ‚úÖ |
| in9.txt | 100,000 | `81908165627` | ‚úÖ |
| in10.txt | 200,000 | `1723796588` | ‚úÖ |

**‡∏™‡∏£‡∏∏‡∏õ:** ‚úÖ 10/10 ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (100%)

---

### ‡∏Ç‡πâ‡∏≠ 2: Sand - Bonus Cases (Large Data)

| Test | n (piles) | Output | Status |
|------|-----------|--------|--------|
| bonus1.txt | ~500,000 | `4666448895363` | ‚úÖ |
| bonus2.txt | ~1,000,000 | `9817992616211` | ‚úÖ |

**‡∏™‡∏£‡∏∏‡∏õ:** ‚úÖ 2/2 ‡∏ú‡πà‡∏≤‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (100%)

üéâ **Bonus cases ‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏°‡∏î!** Min-Heap ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏•‡πâ‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏£‡∏≤‡∏ö‡∏£‡∏∑‡πà‡∏ô!

---

## üéØ ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î

| Exam | Total Tests | Passed | Pass Rate |
|------|-------------|--------|-----------|
| **‡∏Ç‡πâ‡∏≠ 1: Histogram** | 10 | ‚úÖ 10 | 100% |
| **‡∏Ç‡πâ‡∏≠ 2: Sand (Regular)** | 10 | ‚úÖ 10 | 100% |
| **‡∏Ç‡πâ‡∏≠ 2: Sand (Bonus)** | 2 | ‚úÖ 2 | 100% |
| **‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î** | **22** | **‚úÖ 22** | **100%** |

**‚ú® ‡∏ó‡∏∏‡∏Å test case ‡∏ú‡πà‡∏≤‡∏ô‡∏´‡∏°‡∏î! Algorithm ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏£‡∏ß‡∏î‡πÄ‡∏£‡πá‡∏ß**

---

## üí° ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏û‡∏¥‡πÄ‡∏®‡∏© (Extra Credit - ‡∏£‡∏ß‡∏° 10 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)

### üìå **‡∏Ç‡πâ‡∏≠ 1: ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå HistogramSelect ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Sort ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)**

‡∏à‡∏á‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Ç‡πâ‡∏≠‡∏î‡∏µ ‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏µ‡∏¢ ‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Ç‡∏≠‡∏á HistogramSelect ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Sort ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ

---

#### ‚úÖ **‡∏Ç‡πâ‡∏≠‡∏î‡∏µ‡∏Ç‡∏≠‡∏á HistogramSelect:**

**1. ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î**
   - ‡∏Å‡∏≤‡∏£ Sort ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ (QuickSort, MergeSort) ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î n ‡∏ï‡∏±‡∏ß ‚Üí O(n log n)
   - HistogramSelect ‡∏´‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á k ‚Üí O(n log_b n) ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤
   - **‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:** ‡∏´‡∏≤ median ‡∏à‡∏≤‡∏Å 1 ‡∏•‡πâ‡∏≤‡∏ô‡∏ï‡∏±‡∏ß
     - Sort: ‡πÄ‡∏£‡∏µ‡∏¢‡∏á 1M ‡∏ï‡∏±‡∏ß ‚Üí ~20M operations
     - HistogramSelect: ‡∏´‡∏≤‡πÅ‡∏Ñ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á 500K ‚Üí ~2M operations (‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ 10 ‡πÄ‡∏ó‡πà‡∏≤!)
   - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏´‡∏≤ median, percentile

**2. ‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°**
   - Sort ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• [5,2,8,1] ‚Üí [1,2,5,8]
   - HistogramSelect ‡πÑ‡∏°‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö
   - **‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:** transaction log ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ ‡πÅ‡∏ï‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏≤ median amount
   - ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÄ‡∏î‡∏¥‡∏°

**3. ‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡πÑ‡∏î‡πâ‡∏ï‡∏≤‡∏°‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•**
   - ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å b (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô bins) ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
   - ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏î‡∏µ ‚Üí ‡πÉ‡∏ä‡πâ b ‡πÄ‡∏•‡πá‡∏Å (‡πÄ‡∏£‡πá‡∏ß)
   - ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏∞‡∏à‡∏∏‡∏Å ‚Üí ‡πÉ‡∏ä‡πâ b ‡πÉ‡∏´‡∏ç‡πà (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô worst case)

**4. ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î Memory**
   - ‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏≤‡∏£‡πå‡πÄ‡∏£‡∏¢‡πå‡πÉ‡∏´‡∏°‡πà
   - ‡πÉ‡∏ä‡πâ space ‡πÅ‡∏Ñ‡πà O(b) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö bins ‡πÅ‡∏•‡∏∞ O(log n) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö recursion

---

#### ‚ùå **‡∏Ç‡πâ‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏Ç‡∏≠‡∏á HistogramSelect:**

**1. Worst Case ‡∏ä‡πâ‡∏≤‡∏°‡∏≤‡∏Å O(n¬≤)**
   - **‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏:** ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏∞‡∏à‡∏∏‡∏Å‡πÉ‡∏ô bin ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏ã‡πâ‡∏≥ ‡πÜ
   - **‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:** [1,1,1,1,1,1,1,1,1,2] ‡πÅ‡∏ö‡πà‡∏á 4 bins
     - Bin 0: [1,1,1,1,1,1,1,1,1] ‚Üí 9 ‡∏ï‡∏±‡∏ß
     - Bin 1-3: [2] ‚Üí 1 ‡∏ï‡∏±‡∏ß
     - ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏≠‡∏ö‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å ‚Üí ‡∏ï‡πâ‡∏≠‡∏á recursive ‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏≠‡∏ö ‚Üí O(n¬≤)
   - ‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö MergeSort ‡∏ó‡∏µ‡πà‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô O(n log n)

**2. ‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏≤‡∏Ñ‡πà‡∏≤ min/max ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô**
   - ‡∏ï‡πâ‡∏≠‡∏á‡∏ß‡∏ô‡∏´‡∏≤ min ‡πÅ‡∏•‡∏∞ max ‡∏Å‡πà‡∏≠‡∏ô ‚Üí O(n)
   - **‡∏õ‡∏±‡∏ç‡∏´‡∏≤ Outliers:** ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏ú‡∏¥‡∏î‡∏õ‡∏Å‡∏ï‡∏¥‡∏°‡∏≤‡∏Å
     ```
     [10,12,11,13,999999] ‚Üí width ‡πÉ‡∏´‡∏ç‡πà‡∏°‡∏≤‡∏Å ‚Üí bins ‡πÑ‡∏°‡πà‡∏™‡∏°‡∏î‡∏∏‡∏•
     ```

**3. ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç**
   - Histogram binning ‡∏ï‡πâ‡∏≠‡∏á‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ä‡πà‡∏ß‡∏á‡∏Ñ‡πà‡∏≤
   - ‚úÖ ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ: int, long, double
   - ‚ùå ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ: String, Object
   - ‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö Sort ‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏î‡πâ

**4. ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤ b ‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°**
   - b ‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‚Üí bins ‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏¢‡∏≠‡∏∞ ‚Üí recursive ‡∏•‡∏∂‡∏Å ‚Üí ‡∏ä‡πâ‡∏≤
   - b ‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‚Üí ‡πÄ‡∏™‡∏µ‡∏¢‡πÄ‡∏ß‡∏•‡∏≤‡∏ô‡∏±‡∏ö bins ‡∏°‡∏≤‡∏Å ‚Üí overhead ‚Üí ‡∏ä‡πâ‡∏≤
   - ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å b ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°

---

#### üîß **‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤:**

**1. ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ Worst Case O(n¬≤):**

**‡∏Å) Hybrid Algorithm (‡∏ú‡∏™‡∏° Sort):**
```java
if (A.size() <= 50) {
    // ‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡πâ‡∏≠‡∏¢ ‡πÉ‡∏ä‡πâ sort ‡∏ï‡∏£‡∏á ‡πÜ ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤
    Collections.sort(A);
    return A.get(k-1);
} else {
    return histogramSelect(A, b, k);
}
```

**‡∏Ç) ‡πÉ‡∏ä‡πâ QuickSelect ‡∏™‡∏•‡∏±‡∏ö‡∏Å‡∏±‡∏ô:**
```java
// ‡∏ñ‡πâ‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏∞‡∏à‡∏∏‡∏Å‡∏ï‡∏±‡∏ß‡∏°‡∏≤‡∏Å ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô QuickSelect
if (selectedBinCount > 0.8 * A.size()) {
    return quickSelect(selected, k);
}
```

**2. ‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ Outliers:**
- ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡πà‡∏≤ min/max ‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏´‡πà‡∏≤‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ
- ‡∏ï‡∏±‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• 1-5% ‡∏ö‡∏ô‡πÅ‡∏•‡∏∞‡∏•‡πà‡∏≤‡∏á‡∏≠‡∏≠‡∏Å
- ‡πÉ‡∏ä‡πâ logarithmic scale ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà range ‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏°‡∏≤‡∏Å

**3. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤ b ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ä‡∏≤‡∏ç‡∏â‡∏•‡∏≤‡∏î:**
- **‡∏™‡∏π‡∏ï‡∏£‡∏á‡πà‡∏≤‡∏¢:** b = ‚àön ‡∏´‡∏£‡∏∑‡∏≠ b = log(n)
- **‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ï‡∏≤‡∏¢‡∏ï‡∏±‡∏ß:** b = 4-10 (‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏ç‡πà)
- **‡πÉ‡∏ô‡∏™‡∏≠‡∏ö:** ‡∏°‡∏±‡∏Å‡πÉ‡∏´‡πâ b ‡∏°‡∏≤‡πÉ‡∏´‡πâ ‡∏´‡∏£‡∏∑‡∏≠‡πÉ‡∏ä‡πâ b = 4

---

### üìå **‡∏Ç‡πâ‡∏≠ 2: ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á HistogramSelect ‡∏Å‡∏±‡∏ö Sort (5 ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô)**

‡∏à‡∏á‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á HistogramSelect ‡∏Å‡∏±‡∏ö Sorting Algorithms ‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ

---

#### üéØ **1. ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô**

**HistogramSelect:**
- ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ‡∏´‡∏≤‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á k
- ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå: return ‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏µ‡∏¢‡∏ß (single value)
- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: ‡∏´‡∏≤ median ‡∏à‡∏≤‡∏Å [5,2,8,1,9] ‚Üí return 5

**Sort:**
- ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÑ‡∏õ‡∏°‡∏≤‡∏Å
- ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå: return array ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: Sort [5,2,8,1,9] ‚Üí return [1,2,5,8,9]

---

#### ‚ö° **2. ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß (Time Complexity)**

| Algorithm | Average Case | Worst Case |
|-----------|--------------|------------|
| **HistogramSelect** | O(n log_b n) | O(n¬≤) |
| **QuickSort** | O(n log n) | O(n¬≤) |
| **MergeSort** | O(n log n) | O(n log n) ‚úÖ |
| **QuickSelect** | O(n) | O(n¬≤) |

**‡∏™‡∏±‡∏á‡πÄ‡∏Å‡∏ï:**
- HistogramSelect ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ Sort ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Ñ‡πà k-th value
- ‡πÅ‡∏ï‡πà worst case ‡∏≠‡∏≤‡∏à‡∏ä‡πâ‡∏≤‡∏Å‡∏ß‡πà‡∏≤ MergeSort
- QuickSelect ‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡πÅ‡∏ï‡πà‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Å‡∏±‡∏ö HistogramSelect

---

#### üîç **3. ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô**

**HistogramSelect:**
- ‡πÅ‡∏ö‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏° **‡∏ä‡πà‡∏ß‡∏á‡∏Ñ‡πà‡∏≤** (value range)
- ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÉ‡∏ô bins ‚Üí ‡∏´‡∏≤ bin ‡∏ó‡∏µ‡πà k ‡∏≠‡∏¢‡∏π‡πà ‚Üí recursive
- **‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö** ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡∏•‡∏∞‡∏Ñ‡∏π‡πà

**Sort (QuickSort):**
- ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•**‡∏ó‡∏µ‡∏•‡∏∞‡∏Ñ‡∏π‡πà**
- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å pivot ‚Üí ‡πÅ‡∏ö‡πà‡∏á 2 ‡∏ù‡∏±‡πà‡∏á ‚Üí sort ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ù‡∏±‡πà‡∏á
- ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏π‡πà ‚Üí O(n log n) lower bound

**‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏Å:**
- HistogramSelect: ‡πÅ‡∏ö‡πà‡∏á‡∏ï‡∏≤‡∏°**‡∏Ñ‡πà‡∏≤** (distribution-based)
- Sort: ‡πÅ‡∏ö‡πà‡∏á‡∏ï‡∏≤‡∏°**‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö** (comparison-based)

---

#### üé≤ **4. ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô**

**HistogramSelect ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö:**
- ‚úÖ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç (int, long, double)
- ‚úÖ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏ï‡∏±‡∏ß‡∏î‡∏µ
- ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Ñ‡πà k-th value (median, percentile)
- ‚úÖ ‡∏£‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏á‡∏Ñ‡πà‡∏≤ min/max

**Sort ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏Å‡∏±‡∏ö:**
- ‚úÖ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó (‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç, String, Object)
- ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
- ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô worst case (MergeSort)

---

#### üìä **5. Use Cases ‡πÄ‡∏õ‡∏£‡∏µ‡∏¢‡∏ö‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö**

| ‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå | HistogramSelect | Sort |
|-----------|-----------------|------|
| ‡∏´‡∏≤ median ‡∏à‡∏≤‡∏Å 1M ‡∏ï‡∏±‡∏ß | ‚úÖ ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤ | ‚ùå ‡∏ä‡πâ‡∏≤‡∏Å‡∏ß‡πà‡∏≤ |
| ‡∏´‡∏≤ top 10 ‡∏à‡∏≤‡∏Å 1M ‡∏ï‡∏±‡∏ß | ‚ùå ‡πÑ‡∏°‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞ | ‚úÖ sort ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏≠‡∏≤ 10 ‡∏ï‡∏±‡∏ß |
| ‡πÅ‡∏™‡∏î‡∏á leaderboard | ‚ùå ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î | ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á sort |
| ‡∏´‡∏≤ 95th percentile | ‚úÖ ‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏°‡∏≤‡∏Å | ‚ö†Ô∏è ‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ‡πÅ‡∏ï‡πà‡∏ä‡πâ‡∏≤ |
| ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏≤‡∏° A-Z | ‚ùå ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ | ‚úÖ ‡∏ï‡πâ‡∏≠‡∏á sort |

---

#### üîÑ **6. ‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô Worst Case**

**HistogramSelect:**
- ‚ùå **‡πÑ‡∏°‡πà‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô** worst case
- Average case ‡∏î‡∏µ ‡πÅ‡∏ï‡πà worst case ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô O(n¬≤)
- ‡∏Ç‡∏∂‡πâ‡∏ô‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

**Sort:**
- ‚úÖ **MergeSort ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô** O(n log n) ‡πÄ‡∏™‡∏°‡∏≠
- ‚ö†Ô∏è **QuickSort ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô** O(n¬≤) (‡πÅ‡∏ï‡πà‡∏´‡∏≤‡∏¢‡∏≤‡∏Å)
- ‚úÖ **HeapSort ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô** O(n log n) + in-place

---

### üìù **‡∏™‡∏£‡∏∏‡∏õ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á:**

| ‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô | HistogramSelect | Sort |
|---------|-----------------|------|
| **‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢** | ‡∏´‡∏≤ k-th value | ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î |
| **‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß (avg)** | O(n log_b n) | O(n log n) |
| **‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß (worst)** | O(n¬≤) ‚ö†Ô∏è | O(n log n) ‚úÖ |
| **‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏ö‡πà‡∏á** | ‡πÅ‡∏ö‡πà‡∏á‡∏ï‡∏≤‡∏° value range | ‡πÅ‡∏ö‡πà‡∏á‡∏ï‡∏≤‡∏° comparison |
| **‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°** | ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç ‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏î‡∏µ | ‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó |
| **Use Case** | median/percentile | leaderboard/ranking |

**‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:**
- ‡πÉ‡∏ä‡πâ **HistogramSelect** ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏Ñ‡πà k-th value ‡πÅ‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢‡∏î‡∏µ ‚Üí ‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏ß‡πà‡∏≤
- ‡πÉ‡∏ä‡πâ **Sort** ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏´‡∏£‡∏∑‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏Å‡∏±‡∏ô worst case

---

## üöÄ Compile & Run

```powershell
cd d:\Algorithm_Lab

# ‡∏Ç‡πâ‡∏≠ 1: Histogram Select
javac -sourcepath src -d bin src/th/ac/kmutt/cpe/algorithm/wisit/ExamM2/Exam1_HistogramSelect.java
Get-Content src/th/ac/kmutt/cpe/algorithm/wisit/ExamM2/testOne/in1.txt | `
    java -cp bin th.ac.kmutt.cpe.algorithm.wisit.ExamM2.Exam1_HistogramSelect

# ‡∏Ç‡πâ‡∏≠ 2: Sand
javac -sourcepath src -d bin src/th/ac/kmutt/cpe/algorithm/wisit/ExamM2/Exam2_Sand.java
Get-Content src/th/ac/kmutt/cpe/algorithm/wisit/ExamM2/testTwo/in1.txt | `
    java -cp bin th.ac.kmutt.cpe.algorithm.wisit.ExamM2.Exam2_Sand
```

---

## üèóÔ∏è Implementation (OOP Structure)

### ‡∏Ç‡πâ‡∏≠ 1: Histogram Select
```
Exam1_HistogramSelect.java (main program)
    ‚Üì uses
sorting/HistogramSelect.java (algorithm class)
    - histogramSelect()
    - findMin(), findMax()
```

### ‡∏Ç‡πâ‡∏≠ 2: Sand
```
Exam2_Sand.java (main program)
    ‚Üì uses
sorting/SandSort.java (algorithm class)
    - sandSort()
```

**‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:**
```java
// ‡∏Ç‡πâ‡∏≠ 1
HistogramSelect hs = new HistogramSelect();
double result = hs.histogramSelect(A, b, k);

// ‡∏Ç‡πâ‡∏≠ 2
SandSort sand = new SandSort();
long cost = sand.sandSort(n, A);
```

---

## üìù ‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏≠‡∏ö

### ‚úÖ ‡∏Ç‡πâ‡∏≠ 1: Histogram Select
- **Algorithm:** Divide and Conquer with Histogram Binning
- **Key:** ‡∏´‡∏≤‡∏£ width ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà b, ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ max value
- **Complexity:** O(n log_b n) average, O(n¬≤) worst

### ‚úÖ ‡∏Ç‡πâ‡∏≠ 2: Sand
- **Algorithm:** Greedy + Min-Heap (self-implemented, Huffman-like)
- **Key:** Build heap O(n) ‚Üí Extract 2 smallest + Insert merged (repeat)
- **Complexity:** O(n log n)
- **‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î:** ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏ä‡πâ PriorityQueue, Collections.sort() - ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Min-Heap ‡πÄ‡∏≠‡∏á

### ‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏£‡∏£‡∏∞‡∏ß‡∏±‡∏á
- ‡∏Ç‡πâ‡∏≠ 1: **‡∏´‡∏≤‡∏£ width ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà b** ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ `if (idx >= b) idx = b - 1`
- ‡∏Ç‡πâ‡∏≠ 2: **‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Min-Heap ‡πÄ‡∏≠‡∏á** (heapifyUp, heapifyDown, extractMin, insert)
- **‡πÉ‡∏ä‡πâ long ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà int** (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô overflow)
- ‡∏Ç‡πâ‡∏≠ 2: **Build heap ‡∏î‡πâ‡∏ß‡∏¢ bottom-up** (`for i = n/2-1 down to 0: heapifyDown(i)`)

---

**Last Updated:** November 13, 2025  
**Verified:** ‡∏ó‡∏∏‡∏Å test case ‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏î‡∏™‡∏≠‡∏ö (22/22 tests) ‚úì
